#!/bin/sh
#++
# Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
#
#    NAME
#      emCCR - OCM software command line interface
#
#    DESCRIPTION
#      This script is invoked by the user to configure/control the 
#      behavior of Oracle Configuration Manager(OCM). Please see
#      "emCCR help" for more details.
#
#    EXIT CODES
#      0 - Success
#      1 - Prerequisite failure
#      2 - Invalid argument specified
#      3 - Invalid Usage
#      4 - Failed to obtain synchronization lock
#      5 - Corrupt install
#      6 - Upgrade in progress
#      7 - Missing command qualifier value.
#      8 - Not a directory.
#      11 - Unexpected Installation failure
#      12 - License Agreement declined
#      21 - OCM registration failure
#      22 - Registration key mismatch
#      38 - update failed (non mandatory).
#      81 - Package not supported.  
#      82 - Not an OCM package.
#      83 - A package deployment issue was encountered.
#      84 - No access to the specified package.
#      85 - Qualifiers -distribution and -staged_dir are mutually exclusive
#      86 - Invalid directory specified for the -staged_dir qualifier.
#
#--

#
# Reset the locale to ENGLISH for command line operations.
LC_ALL=C
export LC_ALL

# Constant declarations for exit values.
SUCCESS=0
ERR_PREREQ_FAILURE=1
ERR_INVALID_ARG=2
ERR_INVALID_USAGE=3
ERR_LOCK_FAILURE=4
ERR_CORRUPT_INSTALL=5
ERR_UPGRADE_IN_PROGRESS=6
MISSING_QUALIFIER_VALUE=7
NOT_A_DIRECTORY=8
ERR_UNEXPECTED_FAILURE=11
ERR_LICENSE_DECLINED=12
ERR_REGISTRATION_FAILURE=21
ERR_KEY_MISMATCH=22
PKG_NOT_SUPPORTED=81
INVALID_OCM_PKG=82
PKG_DEPLOY_FAILURE=83
PKG_ACCESS_FAILURE=84
INVALID_QUALIFIER_COMBINATION=85
INVALID_DIRECTORY=86

# variables
no_log_flag=0
cron_flag=0
silent_flag=0
upgrade_flag=0
_schedState=""
_downTimestamp=""
collLocktaken=0
Seconds=0
semTakenOp=0
semTakenUpd=0
semUseCount=0
rootUser=0

# Define the paths for /usr/bin. These are used in subsequent path
# specifications for native commands.
_usrLocalBinDir=/usr/local/bin
_usrBinDir=/usr/bin
_binDir=/bin

# Set the variables that map to explicit paths to prevent from trojan
# horse type attacks and allow for more consistent installation experience
# by eliminating the use of aliases.
BASENAME=${_binDir}/basename
CAT=${_binDir}/cat
CD=cd
CHOWN=${_binDir}/chown
CP=${_usrBinDir}/cp
DATE=${_binDir}/date
DIRNAME=${_usrBinDir}/dirname
ECHO=${_binDir}/echo
ID=${_usrBinDir}/id
LS=${_binDir}/ls
MKDIR=${_binDir}/mkdir
MKDIRP="${_binDir}/mkdir -p"
MV=${_binDir}/mv
RM=${_binDir}/rm
RMF="$RM -f"
RMRF="$RM -rf"
SED=${_binDir}/sed
TEE=${_usrBinDir}/tee
TOUCH=${_binDir}/touch
TR=${_usrBinDir}/tr

if [ -f ${_binDir}/cut ]
then
  CUT=${_binDir}/cut
elif [ -f ${_usrBinDir}/cut ]
then
  CUT=${_usrBinDir}/cut
fi

if [ -f ${_binDir}/uname ]
then
  UNAME=${_binDir}/uname
elif [ -f ${_usrBinDir}/uname ]
then
  UNAME=${_usrBinDir}/uname
fi

PLATFORM=`$UNAME | $CUT -f1`
PLATARCH=`$UNAME -m | $CUT -f1`
if [ "$PLATFORM" = "Linux" -a "$PLATARCH" != "ia64" -a "$PLATARCH" != "ppc64" -a "$PLATARCH" != "s390x" ] 
then
  PERLVER=5.10.0
else
  PERLVER=5.8.3
fi

AWK=${_binDir}/awk
if [ "$PLATFORM" = "SunOS" ]
then
    if [ -f ${_binDir}/nawk ]
    then
        AWK=${_binDir}/nawk
    elif [ -f ${_usrBinDir}/nawk ]
    then
        AWK=${_usrBinDir}/nawk
    fi
fi

if [ -f ${_binDir}/egrep ]
then
    EGREP=${_binDir}/egrep
elif [ -f ${_usrBinDir}/egrep ]
then
    EGREP=${_usrBinDir}/egrep
fi

if [ -f ${_binDir}/test ]
then
    TEST=${_binDir}/test
elif [ -f ${_usrBinDir}/test ]
then
    TEST=${_usrBinDir}/test
fi

LOCKFILE=""
if [ -f ${_usrBinDir}/lockfile ]
then
    LOCKFILE=${_usrBinDir}/lockfile
elif [ -f ${_usrLocalBinDir}/lockfile ]
then
    LOCKFILE=${_usrLocalBinDir}/lockfile
fi

#
#decrSemaphore has been moved here because of the ordering requirement for EXIT function path on some platforms 
#
decrSemaphore()
{
  # if we're in upgrade mode, DO NOT USE THE SEMAPHORE!
  if [ $upgrade_flag -ne 1 ] ; then
    # lock the semaphores so we can update the one we're working with
    $LOCKFILE -2 -r 7 -l 15 ${_semaphoreLock} > /dev/null 2>&1
    if [ $? -eq 0 ]; then
      semUseCount=`$CAT $1`
      semUseCount=`expr $semUseCount - 1`

      $ECHO $semUseCount > $1
      # we just released the semaphore, clear the flag
      if [ "$1" = "${_semaphoreOp}" ] ; then
        semTakenOp=0
      else
        semTakenUpd=0
      fi
      # and release the lock
      _tmpSemLock=`$LS -l ${_semaphoreLock} | $AWK '{print $NF}'`
      $RMF ${_semaphoreLock}
      $RMF ${_tmpSemLock}
    else
      $ECHO "Unable to synchronize operation, aborting."
      EXIT $ERR_LOCK_FAILURE
    fi
  fi
}

#
# Exit routine to clean up and then exit (must be declared before the rest of the script)
#
EXIT()
{
  if [ ${collLocktaken} -ne 0 ] ; then
    if [ ! -z "${_collectorLock}" ] ; then
      _tmpCollLock=`$LS -l ${_collectorLock} | $AWK '{print $NF}'`
      $RMF ${_collectorLock}
      $RMF ${_tmpCollLock}
      collLocktaken=0
    fi
  fi

  if [ ${semTakenOp} -ne 0 ] ; then
      decrSemaphore ${_semaphoreOp}
  fi
  if [ ${semTakenUpd} -ne 0 ] ; then
      decrSemaphore ${_semaphoreUpdate}
  fi

  exit $1
}

if [ $PLATFORM = "OSF1" ]
then
  if [ -z "${BIN_SH}" ]
  then
    BIN_SH=xpg4
    export BIN_SH
    $0 "$@"
    EXIT $?
  fi
fi

ROOTCHAR=`$DIRNAME $0 | $CUT -b1`
if [ "${ROOTCHAR}" != "/" -a -z "${PWD}" ]
then
  $ECHO "The current shell is not supported for executing commands using relative paths."
  $ECHO "Either execute the command under the bash or ksh shells, or execute the "
  $ECHO "command using the absolute path."
  EXIT $ERR_PREREQ_FAILURE
fi

# Extract the binary directory specification where this script resides. 
# The enclosed code will come up with an absolute path. 
_OCMBinDir=`$DIRNAME $0 | $TR -s '/'`
# First remove './'s in the beginning
_OCMBinDir=`$ECHO $_OCMBinDir | $AWK '{ if (match($0,/^(\.\/)*/)){ sub(/^(\.\/)*/,"",$0) }; print $0; }'`
# Next replace all '/./'s in between with '/'
_OCMBinDir=`$ECHO $_OCMBinDir | $AWK '{ if (match($0,/\/(\.\/)+/)){ gsub(/\/(\.\/)+/,"/",$0) }; print $0;}'`
# Lastly remove '/.' at the end
_OCMBinDir=`$ECHO $_OCMBinDir | $AWK '{ if (match($0,/\/\.$/)){ sub(/\/\.$/,"",$0) }; print $0; }'`
# Now convert to absolute path
_OCMBinDir=`$ECHO $_OCMBinDir | $AWK -f ${_OCMBinDir}/strip_path.awk PWD=$PWD`
_OCMLibDir=`$DIRNAME $_OCMBinDir`/lib

# Construct the CCR installation directory root based upon the bin
# directory being a child.
LIVELINK_HOME=`$DIRNAME ${_OCMBinDir}`
export LIVELINK_HOME

CCR_HOME=$LIVELINK_HOME
export CCR_HOME

#
# Determine if Shared Oracle Home support is available. This is determined
# thru the new directory 'hosts' under the CCR_HOME.
#
if [ -d "${CCR_HOME}/hosts" ]; then
    _sharedHomesSupported=0
else
    _sharedHomesSupported=1
fi

if [ -z "${LOCKFILE}" ]; then
    LOCKFILE=$CCR_HOME/bin/lockfile
    # We now 'distribute' the lockfile script in the core package
    if [ ! -f $LOCKFILE ]; then
        $ECHO "Error: The Oracle Configuration Manager lockfile script is missing. Exiting..."
        exit $ERR_PREREQ_FAILURE
    fi
fi

#++
# 
# Extracts the Value for the property specified from the base configuration
# file. Value returned in the variable _returnData
# 
# The algorithm iterates thru all the files in precidence order, taking the
# first one present. Order is:
#     
#   (1) $CCR_CONFIG_HOME/config
#   (2) $CCR_CONFIG_HOME/config/default
#   (3) $CCR_HOME/config
#   (4) $CCR_HOME/config/default
#
# Args:
#    property-name, i.e. ccr.disconnected
#    config-basename, i.e. ccr.properties or collector.properties
#
#--
getProperty()
{
   _propertyName=$1
   _propertyFile=$2
   _returnData=""
      
   if [ -z "${_propertyFile}" -o -z "${_propertyName}" ]; then
       ERROR "INTERNAL ERR (getProperty()) - Missing arguments"
       EXIT $ERR_UNEXPECTED_FAILURE
   fi
   
   if [ -f ${CCR_CONFIG_HOME}/config/${_propertyFile} ]; then
       _returnData=`$EGREP "^$_propertyName=" ${CCR_CONFIG_HOME}/config/${_propertyFile} | \
                    $SED -e "s/$_propertyName=[ 	]*//"`
   fi
   
   # check alternate properties files if we come up empty, just in case
   if [ -z "${_returnData}" ] ; then
      if [ -f ${CCR_CONFIG_HOME}/config/default/${_propertyFile} ] ; then
         _returnData=`$EGREP "^$_propertyName=" ${CCR_CONFIG_HOME}/config/default/${_propertyFile} | \
                      $SED -e "s/$_propertyName=[ 	]*//"`
      fi
   fi
   if [ -z "${_returnData}" ] ; then
      if [ -f ${CCR_HOME}/config/${_propertyFile} ] ; then
         _returnData=`$EGREP "^$_propertyName=" ${CCR_HOME}/config/${_propertyFile} | \
                      $SED -e "s/$_propertyName=[ 	]*//"`
      fi
   fi
   if [ -z "${_returnData}" ] ; then
      if [ -f ${CCR_HOME}/config/default/${_propertyFile} ] ; then
         _returnData=`$EGREP "^$_propertyName=" ${CCR_HOME}/config/default/${_propertyFile} | \
                      $SED -e "s/$_propertyName=[ 	]*//"`
      fi
   fi
}

#
# Check to see if this is a valid installation. There are other code paths that 
# are meant to catch the un-registered conditions that arise here. Specifically
# upgrades and failure to re-register. Therefore, the registration can NEVER
# be a catestrophic return code here. The ONLY condition we can use is to 
# verify the directory structure is in tact and the license agreement.
isOCMConfigured()
{
  G_OCMConfigured=0

  if [ -d ${CCR_CONFIG_HOME}/config -a -d ${CCR_CONFIG_HOME}/config/default -a \
       -d ${CCR_CONFIG_HOME}/state -a -d ${CCR_CONFIG_HOME}/state/diagnostic -a \
       -d ${CCR_CONFIG_HOME}/state/previous -a -d ${CCR_CONFIG_HOME}/state/review -a \
       -d ${CCR_CONFIG_HOME}/state/temp -a -d ${CCR_CONFIG_HOME}/state/upload -a \
       -d ${CCR_CONFIG_HOME}/log ] ; then

    checkIfDisconnected

    # Get the property indicating the license agreement is signed.
    getProperty ccr.agreement_signer collector.properties
    _acceptee=${_returnData}
    
    if [ ! -z "${_acceptee}" ] ; then
       G_OCMConfigured=1
    else
        $ECHO "The Oracle Configuration Manager license agreement has not been accepted."
    fi
  else
     $ECHO "The Oracle Configuration Manager state/writeable directory structure is incomplete."
  fi
}

checkIfDisconnected()
{
   getProperty ccr.disconnected collector.properties
   _disconn=${_returnData}
}

setHostName()
{
  CCR_HOST_NAME=`hostname`

  export CCR_HOST_NAME
}

setOCMDirPaths()
{
  # Use what's in the environment if already set
  if [ -z "${CCR_CONFIG_HOME}" ] 
  then
    # Check whether its a shared OCM install
    if [ ${_sharedHomesSupported} -eq 0 ]
    then
      if [ -z "${ORACLE_CONFIG_HOME}" ]
      then
        CCR_CONFIG_HOME="${CCR_HOME}/hosts/${CCR_HOST_NAME}"
      elif [ -d ${ORACLE_CONFIG_HOME} ]
      then
        _isRelative=`$ECHO ${ORACLE_CONFIG_HOME} | $EGREP -c '^/'`
        if [ ${_isRelative} -eq 0 ] ; then
          $ECHO '${ORACLE_CONFIG_HOME} refers to a relative path.'
          $ECHO 'Redefine ORACLE_CONFIG_HOME to refer to an absolute path, or'
          $ECHO 'unset it if the configuration state is in the ccr directory tree.'
          EXIT $ERR_PREREQ_FAILURE
        else
          # strip any trailing dirsep
          ORACLE_CONFIG_HOME=`$ECHO ${ORACLE_CONFIG_HOME} | $SED -e 's/\/*$//'`
          CCR_CONFIG_HOME="${ORACLE_CONFIG_HOME}/ccr"
        fi
      else
        $ECHO '${ORACLE_CONFIG_HOME} should point to the directory containing OCM configurations for the host.'
        EXIT $ERR_PREREQ_FAILURE
      fi
    else
      CCR_CONFIG_HOME=${CCR_HOME}
    fi
  fi

  # OCM should be configured for this host/home, if its NOT
  # Exit
  isOCMConfigured
  if [ $G_OCMConfigured -ne 1 ]
  then
     $ECHO "OCM is not configured for this host or ORACLE_CONFIG_HOME. Please configure OCM first."
     EXIT $ERR_PREREQ_FAILURE
  fi

  export CCR_CONFIG_HOME
}

configMatchesHome()
{
    if [ ${_sharedHomesSupported} -eq 0 ]; then
        _definedHomePath=""
        if [ -f ${CCR_CONFIG_HOME}/config/collector.properties ]; then
            _definedHomePath=`$EGREP '^ccr.binHome=' \
                              ${CCR_CONFIG_HOME}/config/collector.properties | \
                                  $SED -e 's?^ccr.binHome=??'`
        fi

        if [ -z "${_definedHomePath}" -a \
             -f ${CCR_CONFIG_HOME}/config/default/collector.properties ]; then
            _definedHomePath=`$EGREP '^ccr.binHome=' \
                              ${CCR_CONFIG_HOME}/config/default/collector.properties | \
                                  $SED -e 's?^ccr.binHome=??'`
        fi

        if [ "${_definedHomePath}" != "${CCR_HOME}" ]; then
            # Before we error out, check another case for Solaris only
            # Check absolute paths, sh behaves differently on Solaris
            # sh sets pwd to canonical path, replacing all symlinks
            if [ "${PLATFORM}" = "SunOS" ]; then
                _definedHomePath_Abs=`cd $_definedHomePath && pwd -P`
                CCR_HOME_Abs=`cd $CCR_HOME && pwd -P`
            else
                _definedHomePath_Abs=${_definedHomePath}
                CCR_HOME_Abs=${CCR_HOME}
            fi

            if [ "${_definedHomePath_Abs}" != "${CCR_HOME_Abs}" ]; then
                $ECHO "Error: This OCM configuration location corresponds to the installation in "
                $ECHO "the directory: \"${_definedHomePath}\"."
                EXIT $ERR_PREREQ_FAILURE
            fi
        fi
    fi
}

determineJavaVersion()
{
    java_version=`${JAVA_HOME}/bin/java -version 2>&1`
    cmd_exit=$?
    java_version=`$ECHO $java_version | \
                  $EGREP 'java version' | $CUT -d'"' -f2 | $CUT -d'"' -f1`
    G_JAVA_MAJOR_VERSION=`$ECHO $java_version | $CUT -d'.' -f1`
    G_JAVA_MINOR_VERSION=`$ECHO $java_version | $CUT -d'.' -f2`
}
 
determineHttpClientClasspath()
{
    G_HTTP_CLIENT_CLASSPATH="${CCR_HOME}/lib/http_client_11116.jar" 
    if [ "$G_JAVA_MINOR_VERSION" = "2" -o \
         "$G_JAVA_MINOR_VERSION" = "3" -o \
         "$G_JAVA_MINOR_VERSION" = "4" -o \
         "$G_JAVA_MINOR_VERSION" = "5" ]
    then
        G_HTTP_CLIENT_CLASSPATH="${CCR_HOME}/lib/http_client_12.jar" 
    fi  
    export G_HTTP_CLIENT_CLASSPATH
}

setHostName
setOCMDirPaths

# Check to see that the configuration directory in shared mode is a pair to the
# binary tree.
if [  -z "${DERIVECCR_IN_PROGRESS}" ]; then
    configMatchesHome
fi

# Initialize ccr owner and group 
ccrOwner=`$LS -Llnd $CCR_HOME |$AWK '{print $3}'`
ccrGroup=`$LS -Llnd $CCR_HOME |$AWK '{print $4}'`

# Source environment variable before setting any.
# Source the user specified environment that is present in the CCR environment
# snapshot file (maintained by emSnapshotEnv).
if [ -f ${CCR_CONFIG_HOME}/config/emCCRenv ]
then
  . ${CCR_CONFIG_HOME}/config/emCCRenv
fi

# deployment log file name
DEPLOY_LOG=${CCR_CONFIG_HOME}/log/upgrade.log 

# scheduler state file
SCHED_STATE_FILE=${CCR_CONFIG_HOME}/state/sched.state

# operation locking/synchronization
_collectorLock=${CCR_CONFIG_HOME}/state/collector.lock
_semaphoreLock=${CCR_CONFIG_HOME}/state/semaphore.lock
_semaphoreOp=${CCR_CONFIG_HOME}/state/semaphore.op
_semaphoreUpdate=${CCR_CONFIG_HOME}/state/semaphore.update

# OCM is expanded into a home, so the the parent of the install *IS* the
# Oracle home
ORACLE_HOME=`$DIRNAME ${CCR_HOME}`
export ORACLE_HOME

_collectorJar=${_OCMLibDir}/emCCR.jar
_jreLib=${ORACLE_HOME}/JRE/lib

if [ ! -z "${JAVA_HOME_CCR}" ]
then
  _JAVA_HOME=${JAVA_HOME_CCR}
elif [ ! -z "${JAVA_HOME}" ]
  then
    _JAVA_HOME=${JAVA_HOME}
  else
    _JAVA_HOME=${ORACLE_HOME}/jdk
fi

# find jre home, if jdk home is not found
if [ ! -f ${_JAVA_HOME}/bin/java ]
then
   _JAVA_HOME=${ORACLE_HOME}/jre
fi

# Export JAVA_HOME and LD_PRELOAD
JAVA_HOME=${_JAVA_HOME}
export JAVA_HOME

if [ ! -z "${LD_PRELOAD}" ]
then
  export LD_PRELOAD
fi

_JAVA_HOME_BIN=${_JAVA_HOME}/bin

#
#Use jdk/jar if available, Otherwise use our util.
#
if [ -f ${_JAVA_HOME}/bin/jar ]
then
   JAR=${_JAVA_HOME}/bin/jar
else
  if [ -f ${CCR_HOME}/bin/ocmJarUtil ]
  then
     JAR=${CCR_HOME}/bin/ocmJarUtil
  else
     $ECHO "OCM JAR Util is not found."
     EXIT $ERR_PREREQ_FAILURE
   fi
fi

PERL5LIB=$CCR_HOME/engines/${PLATFORM}/perl/lib/site_perl:$CCR_HOME/engines/${PLATFORM}/perl/lib:$CCR_HOME/sysman/admin/scripts:$CCR_HOME/sysman/admin/discover

PERL_BIN=$CCR_HOME/engines/${PLATFORM}/perl/bin
export PERL5LIB

#
# Pass along the shared library path. The shared library path is defined
# as a system property that equates to a string that is a name/value pair
# that is comma separated.
#

shlib_path="-DSHLIB_VAR=LD_LIBRARY_PATH=$CCR_HOME/engines/${PLATFORM}/perl/lib/${PERLVER}"

_perl5lib="-DPERL5LIB=${PERL5LIB}"
_ccrJavaHome="-DCCR_JAVA_HOME=${_JAVA_HOME}"

LD_LIBRARY_PATH=$CCR_HOME/lib:$CCR_HOME/engines/${PLATFORM}/perl/lib/${PERLVER}
export LD_LIBRARY_PATH

if [ "$PLATFORM" = "HP-UX" ]
then
  shlib_path="-DSHLIB_VAR=SHLIB_PATH=${CCR_HOME}/engines/${PLATFORM}/perl/lib/${PERLVER}" 
  SHLIB_PATH=$CCR_HOME/lib
  export SHLIB_PATH
fi

jit_flag=""
if [ "$PLATFORM" = "AIX" ]
then
  shlib_path="-DSHLIB_VAR=LIBPATH=${CCR_HOME}/engines/${PLATFORM}/perl/lib/${PERLVER}"
  LIBPATH=$CCR_HOME/lib
  export LIBPATH
  jit_flag="-Djava.compiler=NONE"
fi

#
# Set the umask for all operations
umask 077

#
# OCM executables.
sched_executable=${_OCMBinDir}/nmz
collector_executable=${_OCMLibDir}/emCCRCollector
sched_ctl=${_OCMBinDir}/nmzctl

#
# Get the location of the temporary directory, defaulting to /tmp
#
if [ -z "${CCR_TEMP}" ]
then
  CCR_TEMP=/tmp
  export CCR_TEMP
fi

CWD=`pwd`

#
# Define helper routines
#

# 
# Std check to see if Java is present in the _JAVA_HOME and if
# not, issue a std error. This is only called in placed right before
# java is used.
# 
exitIfNoJava()
{
  if [ ! -d ${_JAVA_HOME} -o \
       ! -d ${_JAVA_HOME}/bin -o \
       ! -f ${_JAVA_HOME}/bin/java ]
  then
    $ECHO "Error executing requested command. Java was not found."
    $ECHO "Define JAVA_HOME to a JDK that is 1.2.2 or greater and reissue the command."
    EXIT $ERR_PREREQ_FAILURE
  fi
}

#
# Checks that scheduler and collector are present.
# Otherwise, exits.
#
exitIfExecsMissing()
{
  if test ! -f $sched_executable -o ! -f $collector_executable;  then 
    # something wrong with scheduler/collector.
    $ECHO "Error: Oracle Configuration Manager scheduler/collector is missing. Exiting..." 1>&2
    EXIT $ERR_PREREQ_FAILURE
  fi
}

#
# Display the banner 
#
VersionInfo="Oracle Configuration Manager - Release: 12.1.2.0.3 - Production"
CopyrightInfo="Copyright (c) 2005, 2015, Oracle and/or its affiliates.  All rights reserved."
banner()
{
  $ECHO "${VersionInfo}"
  $ECHO "${CopyrightInfo}"
  $ECHO "------------------------------------------------------------------"
}

#
# Display the usage of this script. ROOT can only perform status, collect, 
# upload, clear and help commands. Usage is conditionalized to just what they
# can perform.
#
printUsage()
{
  if [ "$_disconn" = "true" ]; then
    if [ -f ${sched_executable} -a -f ${collector_executable} ] ;  then 
      $ECHO "Usage: "
      $ECHO "    emCCR [-annotation=\"annotation string\"] [-jarfile=\"Jar filespec for disconnected collection jar.\"] collect"
      $ECHO "    emCCR status"
      if [ $rootUser -eq 0 -o ${_ORACLE_HOME_OWNER} -eq 0 ]; then
        $ECHO "    emCCR enable_target | disable_target"
        $ECHO "    emCCR enable_diagchecks | disable_diagchecks"
      fi
    else
      $ECHO "Oracle Configuration Manager client installed in Mini mode. You must update to full client to perform any other operations:"
    fi
    if [ $rootUser -eq 0 -o ${_ORACLE_HOME_OWNER} -eq 0 ]; then
      $ECHO "    emCCR update_components [-silent] -staged_dir=\"Directory containing OCM packages\" | -distribution=\"OCM installation kit path\""
    fi
    $ECHO "    emCCR help"
  else
    # New command added here should be handled in disconnected mode as: "not supported in disconnected mode"
    $ECHO "Usage: "
    if [ $rootUser -eq 0 -o ${_ORACLE_HOME_OWNER} -eq 0 ]; then
    $ECHO "    emCCR start| stop| status"
    else
    $ECHO "    emCCR status"
    fi

    if [ $rootUser -eq 0 -o ${_ORACLE_HOME_OWNER} -eq 0 ]; then
    $ECHO "    emCCR set collection_interval=\"[FREQ=MONTHLY | WEEKLY | DAILY]"
    $ECHO "                              [; BYMONTHDAY=1 to 31, when FREQ is MONTHLY]"
    $ECHO "                              [; BYDAY=MON to SUN, when FREQ is WEEKLY]"
    $ECHO "                              [; BYHOUR=0 to 23]"
    $ECHO "                              [; BYMINUTE=0 to 59]\" "
    $ECHO "             DAILY is the default Frequency."
    $ECHO "    emCCR hold | resume"
    $ECHO "    emCCR [-annotation=\"annotation string\"] collect | upload | getupdates"
    $ECHO "    emCCR [-verbose] [-register] test"
    $ECHO "    emCCR register"
    $ECHO "    emCCR automatic_update on/off"
    $ECHO "    emCCR enable_target | disable_target"
    $ECHO "    emCCR enable_diagchecks | disable_diagchecks"
    else
    $ECHO "    emCCR [-annotation=\"annotation string\"] collect | upload"
    fi
    $ECHO "    emCCR upload -diagnostic=SR=Service request number,FILE=Absolute path of diagnostic package [-restart] [-force]"
    $ECHO "    emCCR status -diagnostic[=SR=Service request number,FILE=Absolute path of diagnostic package]"
    $ECHO "    emCCR clear -diagnostic[=SR=Service request number,FILE=Absolute path of diagnostic package] [-completed] [-force]"
    if [ $rootUser -eq 0 -o ${_ORACLE_HOME_OWNER} -eq 0 ]; then
    $ECHO "    emCCR update_components [-silent] -staged_dir=\"Directory containing OCM packages\" | -distribution=\"OCM installation kit path\""
    fi
    $ECHO "    emCCR help"
fi
}

#
# If found un-registered, silently registers.
# On registration failure, print the error message.
#
reRegisterIfNeeded()
{
  if [ ! -f ${CCR_CONFIG_HOME}/config/default/uplinkreg.bin ]
  then
    CCR_NOUPDATE=1
    export CCR_NOUPDATE
    OUTPUT=`$collector_executable -silent register 2>&1`
    _reregisterStatus=$?
    CCR_NOUPDATE=
    export CCR_NOUPDATE

    if [ ${_reregisterStatus} -ne 0 ]
    then
      $ECHO ""
      $ECHO "The Oracle Configuration Manager was found to be un-registered."
      $ECHO "The attempted re-registration failed with the following reason:"
      $ECHO ""
      $ECHO ${OUTPUT}
      $ECHO ""
      $ECHO "Please re-attempt the requested operation once the error condition is resolved."
      EXIT $ERR_REGISTRATION_FAILURE
    fi
  fi
}

#
# This function checks if the install is licensed. If not, displays an error
# message and exits.
# Additionally, if attempt-registration argument is passed, it tries to 
# re-register if not already registered.
#
exitIfLicenseNeedsAcceptance()
{
  _attemptReregistration=$1
  _licenseAccepted=0
  if [ -f ${CCR_CONFIG_HOME}/config/collector.properties ]
  then
    # Get the state of the license agreement.
    getProperty ccr.agreement_signer collector.properties
    _acceptee=${_returnData}
    
    if [ ! -z "${_acceptee}" ]
    then
      _licenseAccepted=1
    fi
  fi
  if [ $_licenseAccepted -eq 0 -a "$action" != "config" ]
  then
    $ECHO ""
    $ECHO "Unable to perform the requested operation."
    $ECHO "The License Agreement has not been accepted."
    $ECHO "Re-run \"\${ORACLE_HOME}/ccr/bin/emCCR config\" to accept the license agreement."
    EXIT $ERR_LICENSE_DECLINED
  fi
    
  if [ ! -z "${_attemptReregistration}" ]
  then
    reRegisterIfNeeded
  fi
}

# This function calculates the total no. of seconds from epoch time
# takes the parameters  as follows YYYY MM DD HH M SS
# and puts the calculated value to Global variable Seconds
Convert_date_Seconds()
{
 Seconds=`$ECHO $@ | $AWK ' { y=$1;m=$2;d=$3; H=$4;M=$5;S=$6

t=int((y-1600+3)/4)-int((y-1600+99)/100)+int((y-1600+399)/400)-90

dd=(y-1970)*365+t
for(i=1;i<m;++i){ t=31

if(i==4||i==6||i==9||i==11)t=30
if(i==2){t=28;if((y%4)==0&&((y%100)||(y%400)==0))t=29} dd=dd+t }
dd=dd+d-1;
print dd" 24*"H"+60*"M"+60*"S"+p" } ' |dc `
}

#
# Calls the perl script to display the status of the PL/SQL version.
# The perl script compares the version in the generated .ll file
# with the version of the installed PL/SQL files.
#
sqlVersionStatus()
{
  if [ -f ${PERL_BIN}/perl ]; then
    PERL_INSTALLED=`$PERL_BIN/perl -e 'print "Y"' > /dev/null 2>&1`
    if [ $? -eq 0 ] ; then
      $PERL_BIN/perl $CCR_HOME/sysman/admin/scripts/ccr/cfVersionMisMatchStatus.pl  $CCR_HOME `hostname`
    fi
  fi
}

# Check whether diagchecks are disabled, or there are diagcheck properties
# that need to be configured
diagcheckStatus()
{
  exitIfNoJava
  incrSemaphore ${_semaphoreOp}
  ${_JAVA_HOME_BIN}/java -DORACLE_HOME=${ORACLE_HOME} \
    -DCCR_HOME=${CCR_HOME} \
    -DCCR_CONFIG_HOME=${CCR_CONFIG_HOME} \
    -DPLATFORM=${PLATFORM} ${_ccrJavaHome} -DLOG_HOME=${CCR_CONFIG_HOME}/log \
    -classpath ${G_HTTP_CLIENT_CLASSPATH}:${_collectorJar} ${jit_flag} oracle.sysman.ccr.collector.cli.Cli status_diagchecks
  decrSemaphore ${_semaphoreOp}
}

#
# This function is called for post command processing.
#
postCmdProcessing()
{
  PACKAGES_AVAILABLE=35
  # Processing for getupdates command($action = "getupdates")
  # If we have downloaded some packages, deploy them now.
  # nmzctl returns PACKAGES_AVAILABLE retcode when collector has
  # downloaded updates.
  if [ "$1" = $PACKAGES_AVAILABLE -a "$action" = "getupdates" ] ; then
    state=0
    deployPackages "$state"
  fi
}

#
# This function is called for pre command processing.
#
preCmdProcessing()
{
  # Explicitly setting to CCR_HOME
  cd ${CCR_HOME}

  if [ "$action" = "start" -o \
       "$action" = "collect" ] ; then
    exitIfLicenseNeedsAcceptance reregister
  else
    exitIfLicenseNeedsAcceptance
  fi
  #
  # Attempt to deploy the CCR packages (if any exist) unless the
  # environ variable CCR_NOUPDATE is set. This is to prevent recursive
  # calls during module installations that require calling thru to 
  # the emCCR script.
  #
  if [ "$action" = "start" -o \
       "$action" = "collect" -o \
       "$action" = "upload" -o \
       "$action" = "getupdates" ] ; then
    # Check whether CCR is running if it is, we need to make sure
    # that its running even after call to deploypackages
    $sched_ctl "status" > /dev/null 2>&1
    state=$?

    deployPackages "$state"
  fi
}

# 
# Calls deployPackages to deploy any packages in the pending directory
#
deployPackages()
{
  # Do not perform the functions within unless we are the oracle home owner.
  if [ $rootUser -eq 1 -a ${_ORACLE_HOME_OWNER} -ne 0 ]; then
    return
  fi

  # Before calling deployPackages verify the install
  verifyInstall

  if [ -z "${CCR_NOUPDATE}" ] ; then
    if [ $no_log_flag -eq 1 ]; then
      ${_OCMBinDir}/deployPackages
    else
      CCR_TIMESTAMP="1";
      export CCR_TIMESTAMP
      ${_OCMBinDir}/deployPackages 2>&1 | $TEE -a $DEPLOY_LOG
      # Change ownership to CCR_HOME owner
      changeOwner "${DEPLOY_LOG}"
    fi

    # See do we need to restart scheduler
    if [ "$1" = "0" ] ; then
      _proceedWithStart=1
      #
      # Read scheduler state from state file, make sure it hasn't been 
      # forcefully stopped vs. "DOWN_FOR_UPGRADE"
      #
      checkSchedulerState
      if [ "${_schedState}" = "STOPPED" ] ; then
        _proceedWithStart=0
      fi

      # we're starting the scheduler after upgrade
      if [ ${_proceedWithStart} -ne 0 ] ; then
        $sched_ctl -upgrade start > /dev/null 
      fi
    fi
  fi
}

#++
#
# Determines if we are running in disconected mode. if we are sets the
# global variable G_DISCONNECTED_MODE to 1.
#
#--
isDisconnected()
{
    # Retrieves the property from the 
    getProperty "ccr.disconnected" collector.properties
    G_DISCONNECTED_MODE=`$ECHO ${_returnData} | $TR "[A-Z]" "[a-z]"`
    
    if [ ! -z "${G_DISCONNECTED_MODE}" -a "${G_DISCONNECTED_MODE}" = "true" ] ; then
        G_DISCONNECTED_MODE=1
    else
        G_DISCONNECTED_MODE=0
    fi
}     

verifyInstall()
{
    # Determine if we are in disconnected mode.
    isDisconnected
    
    # Setup/Configuration changes performed for the non-disconnected case.
    if [ $G_DISCONNECTED_MODE -eq 0 ]
    then
    
       getProperty "ccr.registration_mode" ccr.properties
       _REG_METHOD=${_returnData}
       
       if [ ! -z "${_REG_METHOD}" ]; then
          if [ "${_REG_METHOD}" = "email" ]; then
             getProperty "ccr.metalink_email.address" ccr.properties
             _EMAILID=${_returnData}
             
             getProperty "ccr.registration_ct" ccr.properties
             _CipherText=${_returnData}
             
             if [ -z "$_EMAILID" -o -z "${_CipherText}" ]; then
                ERROR "The current configuration information appears to be corrupted. Please run configCCR to reconfigure."
                EXIT $ERR_CORRUPT_INSTALL
             fi
          elif [ "${_REG_METHOD}" = "csi" ]; then
             getProperty "ccr.support_id" ccr.properties
             _CSI=${_returnData}

             getProperty "ccr.registration_ct" ccr.properties
             _CipherText=${_returnData}

             if [ -z "${_CSI}" -o -z "${_CipherText}" ]
             then
                ERROR "The current configuration information appears to be corrupted. Please run configCCR to reconfigure."
                EXIT $ERR_CORRUPT_INSTALL
             fi
          fi
       else
          getProperty "ccr.support_id" ccr.properties
          _CSI=${_returnData}
   
          getProperty "ccr.metalink_id" ccr.properties
          _MLID=${_returnData}

          if [ -z "${_CSI}" -o -z "${_MLID}" ]
          then
             ERROR "The current configuration information appears to be corrupted. Please run configCCR to reconfigure."
             EXIT $ERR_CORRUPT_INSTALL
          fi
       fi
    fi
}

checkSchedulerState()
{
  #
  # Read scheduler state from state file
  #
  if [ -f ${SCHED_STATE_FILE} -a -r ${SCHED_STATE_FILE} ] ; then
    _schedState=`$EGREP '^sched_state=' $SCHED_STATE_FILE | $SED -e "s?^sched_state=??" | $CUT -d',' -f1`
    _downTimestamp=`$EGREP '^sched_state=' $SCHED_STATE_FILE | $SED -e "s?^sched_state=??" | $CUT -d',' -f2`
  fi
}

#
# semaphore operations (maintain count of semaphore usage)
#
initSemaphores()
{
  if [ ! -w ${CCR_CONFIG_HOME}/state ]; then
     banner
     $ECHO "Unable to satisfy request - initialization failure."
     $ECHO "${CCR_CONFIG_HOME}/state is not writeable."
     EXIT $ERR_UNEXPECTED_FAILURE
  fi

  $LOCKFILE -2 -r 7 -l 15 ${_semaphoreLock} > /dev/null 2>&1
  if [ $? -ne 0 ]; then
     $ECHO "Unable to initialize semaphore lock, aborting."
     EXIT $ERR_LOCK_FAILURE
  fi

  # Change ownership to CCR_HOME owner
  changeOwner "${_semaphoreLock}"

  if [ ! -s ${_semaphoreOp} ] ; then
    $ECHO 0 > ${_semaphoreOp}
  else
    check=`$CAT ${_semaphoreOp}`
    check2=`$ECHO ${check} | $TR -dc "[0-9]"`
    if [ -z "${check}" -o "${check}" != "${check2}" ] ; then
      $ECHO 0 > ${_semaphoreOp}
    fi
  fi

  # Change ownership to CCR_HOME owner
  changeOwner "${_semaphoreOp}"

  if [ ! -s ${_semaphoreUpdate} ] ; then
    $ECHO 0 > ${_semaphoreUpdate}
  else
    check=`$CAT ${_semaphoreUpdate}`
    check2=`$ECHO ${check} | $TR -dc "[0-9]"`
    if [ -z "${check}" -o "${check}" != "${check2}" ] ; then
      $ECHO 0 > ${_semaphoreUpdate}
    fi
  fi

  # Change ownership to CCR_HOME owner
  changeOwner "${_semaphoreUpdate}"

    _tmpSemLock=`$LS -l ${_semaphoreLock} | $AWK '{print $NF}'`
  $RMF ${_semaphoreLock}
  $RMF ${_tmpSemLock}
}

incrSemaphore()
{
  # if we're in upgrade mode, DO NOT USE THE SEMAPHORE!
  if [ $upgrade_flag -ne 1 ] ; then
    # the opposing semaphore will be our blocker
    if [ "$1" = "${_semaphoreOp}" ] ; then
      _conflict=${_semaphoreUpdate}
    else
      _conflict=${_semaphoreOp}
    fi

    # check the value of the opposing semaphore
    $LOCKFILE -2 -r 7 -l 15 ${_semaphoreLock} > /dev/null 2>&1
    if [ $? -ne 0 ]; then
       $ECHO "Unable to acquire semaphore lock to synchronize operation, aborting."
       EXIT $ERR_LOCK_FAILURE
    fi
    _mustWait=`$CAT ${_conflict}`
    if [ -z "${_mustWait}" ]; then
       _mustWait=0
    fi
    _tmpSemLock=`$LS -l ${_semaphoreLock} | $AWK '{print $NF}'`
    $RMF ${_semaphoreLock}
    $RMF ${_tmpSemLock}

    if [ ${_mustWait} -gt 0 ] ; then
      $ECHO "Operation blocked, waiting..."
      _willWait=120
      while [ ${_mustWait} -gt 0 -a ${_willWait} -gt 0 ] ; do
        sleep 1
        _willWait=`expr ${_willWait} - 1`

        # recheck after sleep
        $LOCKFILE -2 -r 7 -l 15 ${_semaphoreLock} > /dev/null 2>&1
        if [ $? -ne 0 ]; then
           $ECHO "Unable to acquire semaphore lock to synchronize operation, aborting."
           EXIT $ERR_LOCK_FAILURE
        fi
        _mustWait=`$CAT ${_conflict}`
        if [ -z "${_mustWait}" ]; then
           _mustWait=0
        fi
        _tmpSemLock=`$LS -l ${_semaphoreLock} | $AWK '{print $NF}'`
        $RMF ${_semaphoreLock}
        $RMF ${_tmpSemLock}

      done
      # after loop exit, check to see if the blocking semaphore is still set
      if [ ${_mustWait} -gt 0 ] ; then
        $ECHO "Operation still blocked; aborting!"
        EXIT $ERR_UNEXPECTED_FAILURE
      fi
    fi
    # now lock the semaphores and take care of the one we want
    $LOCKFILE -2 -r 7 -l 15 ${_semaphoreLock} > /dev/null 2>&1
    if [ $? -eq 0 ]; then
      semUseCount=`$CAT $1`
      semUseCount=`expr $semUseCount + 1`

      $ECHO $semUseCount > $1
      # indicate which semaphore we updated
      if [ "$1" = "${_semaphoreOp}" ] ; then
        semTakenOp=1
      else
        semTakenUpd=1
      fi
      # and release the lock
      _tmpSemLock=`$LS -l ${_semaphoreLock} | $AWK '{print $NF}'`
      $RMF ${_semaphoreLock}
      $RMF ${_tmpSemLock}
    else
      $ECHO "Unable to synchronize operation, aborting."
      EXIT $ERR_LOCK_FAILURE
    fi
  fi
}


cleanupTrap()
{
  # reset ownership of all dynamic files
  resetCCRPerms

  # clean up any locks/semaphores taken out
  if [ ${collLocktaken} -ne 0 ] ; then
    $RMF ${_collectorLock}
    collLocktaken=0
  fi
  if [ ${semTakenOp} -ne 0 ] ; then
      decrSemaphore ${_semaphoreOp}
  fi
  if [ ${semTakenUpd} -ne 0 ] ; then
      decrSemaphore ${_semaphoreUpdate}
  fi

  # Exit here or the normal path may cause double decrements of the 
  # semaphores.
  trap 0
  exit $ERR_UNEXPECTED_FAILURE
}

#
# Display more status after done with scheduler 
#
postSchedulerStatus()
{
  #Add registration date
  if [ -f ${CCR_CONFIG_HOME}/config/default/uplinkreg.bin ] ; then
    REG_DATE=`$EGREP "^[ ]*key.registered[ ]*=" \
      ${CCR_CONFIG_HOME}/config/default/uplinkreg.bin| \
      $CUT -d= -f 2 |$SED 's/\\\\//g'`
    if [ ! -z "${REG_DATE}" ] ; then
      $ECHO "Registered At            ${REG_DATE}"
    fi
  fi
  #Add auto update
  AU_DISPLAY_VALUE=On
  getProperty "ccr.autoupdate" collector.properties
  AUTO_UPDATE=${_returnData}

  #Add repeater, proxy configurations
  getProperty "ccr.endpoint.is_repeater" ccr.properties
  IS_REPEATER=${_returnData}
  getProperty "ccr.endpoint" ccr.properties
  END_POINT=${_returnData}
  getProperty "http.proxyHost" ccr.properties
  PROXY_HOST=${_returnData}
  getProperty "http.proxyUser" ccr.properties
  PROXY_USER=${_returnData}
  getProperty "http.proxyPort" ccr.properties
  PROXY_PORT=${_returnData}
  END_POINT=`$ECHO $END_POINT | $SED 's/\\\\//g'`

  # Now report what we found
  if [ ! -z "${AUTO_UPDATE}" ] ; then
    if [ "$PLATFORM" = "Linux" ]; then
      AUTO_UPDATE=`$ECHO $AUTO_UPDATE | $SED 's/true/On/i' | $SED 's/false/Off/i'`
    else
      AUTO_UPDATE=`$ECHO $AUTO_UPDATE | $SED 's/true/On/g' | $SED 's/false/Off/g'`
    fi
    AU_DISPLAY_VALUE=$AUTO_UPDATE
  fi
  if [ ! -z "${PROXY_USER}" ] ; then
    PROXY_USER="$PROXY_USER@"
  fi
  if [ ! -z "${PROXY_PORT}" ] ; then
    PROXY_PORT=":$PROXY_PORT"
  fi
  $ECHO "Automatic Update         ${AU_DISPLAY_VALUE}"
  if [ "$IS_REPEATER" != "true" ] ; then
    $ECHO "Collector Mode           Connected"
  else
    $ECHO "Collector Mode           Connected (via Oracle Support Hub)"
    $ECHO "Oracle Support Hub URL   ${END_POINT}"
  fi
  if [ ! -z "${PROXY_HOST}" ] ; then
    $ECHO "HTTP Proxy               ${PROXY_USER}${PROXY_HOST}${PROXY_PORT}"
  fi
  diagcheckStatus

  if [ "$AU_DISPLAY_VALUE" = "Off" ] ; then
    #automatic update is off,
    #Check if upload can be done.
    #This will give a warning to let user aware that if there is
    #a mandatory package available for download but automatic update is 
    #disabled, collections cannot be uploaded. 
    exitIfNoJava
    ${_JAVA_HOME_BIN}/java -DORACLE_HOME=${ORACLE_HOME} -DCCR_HOME=${CCR_HOME} -DCCR_CONFIG_HOME=${CCR_CONFIG_HOME} \
      -DPLATFORM=${PLATFORM}  ${_perl5lib} ${shlib_path} ${jit_flag} ${_ccrJavaHome} \
      -DLOG_HOME=${CCR_CONFIG_HOME}/log -DPERL_HOME=$CCR_HOME/engines/${PLATFORM}/perl \
      -classpath ${G_HTTP_CLIENT_CLASSPATH}:${_collectorJar} oracle.sysman.ccr.collector.cli.Cli can_upload  
  fi
  sqlVersionStatus
}

# Check the file ownership. Only CCR Directory owners can run CCR.
exitIfNotOwner()
{
  # Determine the owner of the ORACLE_HOME directory. This is not
  # fullproof, but will indicate the owner of the home.
  _UID=`$ID | $CUT -d'=' -f2 | $CUT -d'(' -f1`
  _CCR_OWNER=`$LS -Llnd $CCR_HOME |$AWK '{print $3}'`
  _ORACLE_HOME_OWNER=`$LS -Llnd $ORACLE_HOME |$AWK '{print $3}'`
  if [ ${_UID} -ne ${_CCR_OWNER} ]; then
    if [ ${_UID} -eq 0 ]; then
      rootUser=1
    else
      $ECHO "*****"
      $ECHO "Only the owner of the Oracle Configuration Manager directory "
      $ECHO "may issue commands."
      $ECHO "*****"
      EXIT $ERR_PREREQ_FAILURE
    fi
  fi
}

# Writes to STDERR 
ERROR()
{
  if [ $silent_flag -eq 0 ]; then
    $ECHO "$@" 1>&2
  fi
}

# Validate command passed to emCCR
validateCmd()
{
  cmd=`$ECHO $1 | $TR '[A-Z]' '[a-z]' | $SED -e 's/ .*$//'`
  case "$cmd" in
    "start"                     ) ;;
    "stop"                      ) ;;
    "status"                    ) ;;
    "set"                       ) ;;
    "collection_interval="      ) ;;
    "hold"                      ) ;;
    "resume"                    ) ;;
    "collect"                   ) ;;
    "upload"                    ) ;;
    "getupdates"                ) ;;
    "test"                      ) ;;
    "register"                  ) ;;
    "automatic_update"          ) ;;
    "on"                        ) ;;
    "off"                       ) ;;
    "enable_target"             ) ;;
    "disable_target"            ) ;;
    "enable_diagchecks"         ) ;;
    "disable_diagchecks"        ) ;;
    "config"                    ) ;;
    "clear"                     ) ;;
    "update_components"         ) ;;
    "help"                      ) ;;
    "_get"                      ) ;;
    "_set"                      ) ;;
    "_hold"                     ) ;;
    "_resume"                   ) ;;
    "stop_abort"                ) ;;
    * ) banner
      $ECHO "\"$1\" is not a valid command."
      printUsage
      EXIT $ERR_INVALID_ARG 
      ;;
  esac
}

# Validate qualifiers for *emCCR start* command
validateStartQual()
{
  if [ "$_disconn" = "true" ]; then
    return 0
  fi
  for i in "$@"
    do
      if [ "$PLATFORM" = "Linux" ]; then
        j=`expr "${i}" : $hyphen`
      else
        j=`expr "${i}" : [$hyphen]`
      fi

      if [ ${j} -ne 0 ] ; then
        # We got a qualifier
        # Convert to lower case
        qual=`$ECHO $i | $TR '[A-Z]' '[a-z]' | $SED -e 's/ .*$//'`
        case "$qual" in
          "-cron"                   )
                                    cron_flag=1
                                    ;;
          "-silent"                 )
                                    silent_flag=1
                                    ;;
          "-nocollect"              ) ;;
          "-nolog"                  ) 
                                    no_log_flag=1
                                    ;;
          "-upgrade"                ) 
                                    upgrade_flag=1
                                    ;;
          * ) banner
            $ECHO "\"${i}\" is an invalid qualifier for command \"${action}\""
            printUsage
            EXIT $ERR_INVALID_ARG 
            ;;
         esac
       fi
     done
  #end for
}

# Validate qualifiers for *emCCR stop_abort* command
validateStopAbortQual()
{
  for i in "$@"
    do
      if [ "$PLATFORM" = "Linux" ]; then
        j=`expr "${i}" : $hyphen`
      else
        j=`expr "${i}" : [$hyphen]`
      fi

      if [ ${j} -ne 0 ] ; then
        # We got a qualifier
        # Convert to lower case
        qual=`$ECHO $i | $TR '[A-Z]' '[a-z]' | $SED -e 's/ .*$//'`
        case "$qual" in
          "-upgrade"                ) 
                                    upgrade_flag=1
                                    ;;
          * ) banner
            $ECHO "\"${i}\" is an invalid qualifier for command \"${action}\""
            printUsage
            EXIT $ERR_INVALID_ARG 
            ;;
         esac
       fi
     done
  #end for
}

# Validate qualifiers for *emCCR upload* command
validateUploadQual()
{
  if [ "$_disconn" = "true" ]; then
    return 0
  fi
  for i in "$@"
    do
      if [ "$PLATFORM" = "Linux" ]; then
        j=`expr "${i}" : $hyphen`
      else
        j=`expr "${i}" : [$hyphen]`
      fi

      if [ ${j} -ne  0 ] ; then
        # We got a qualifier
        # Convert to lower case
        qual=`$ECHO $i | $TR '[A-Z]' '[a-z]' | $SED -e 's/ .*$//'`
        case "$qual" in
          "-annotation"                 ) ;;
          -annotation=*                 ) ;;
          "-diagnostic"                 ) ;;
          -diagnostic=*                 ) ;;
          "-force"                      ) ;;
          "-restart"                    ) ;;
          "-nointeractive"              ) ;;
          * ) banner
            $ECHO "\"${i}\" is an invalid qualifier for command \"${action}\""
            printUsage
            EXIT $ERR_INVALID_ARG 
            ;;
        esac
      fi
    done
  #end for
}

# Validate qualifiers for *emCCR collect* command
validateCollectQual()
{
  if [ "$_disconn" = "true" -a "$action" != "collect" ]; then
    return 0
  fi
  for i in "$@"
    do
      if [ "$PLATFORM" = "Linux" ]; then
        j=`expr "${i}" : $hyphen`
      else
        j=`expr "${i}" : [$hyphen]`
      fi

      if [ ${j} -ne 0 ] ; then
        # We got a qualifier
        # Convert to lower case
        qual=`$ECHO $i | $TR '[A-Z]' '[a-z]' | $SED -e 's/ .*$//'`
        case "$qual" in
          "-annotation"                 ) ;;
          -annotation=*                 ) ;;
          "-jarfile"                       );;  
           -jarfile=*                      );; 
           * ) banner
            $ECHO "\"${i}\" is an invalid qualifier for command \"${action}\""
            printUsage
            EXIT $ERR_INVALID_ARG 
            ;;
        esac
      fi
    done
  #end for
}

# Validate qualifiers for following emCCR commands
# stop, set, hold, resume, register, automatic_updates, 
# enable_target, disable_target, config
validateNoQual()
{
  if [ "$_disconn" = "true" -a \
       "$action" != "help" -a \
       "$action" != "enable_target" -a \
       "$action" != "disable_target" -a \
       "$action" != "enable_diagchecks" -a \
       "$action" != "disable_diagchecks" ]; then
    return 0
  fi
  for i in "$@"
    do
      if [ "$PLATFORM" = "Linux" ]; then
        j=`expr "${i}" : $hyphen`
      else
        j=`expr "${i}" : [$hyphen]`
      fi

      if [ ${j} -ne 0 ] ; then
        # We got a qualifier
        banner
        $ECHO "\"${i}\" is an invalid qualifier for command \"${action}\""
        printUsage
        EXIT $ERR_INVALID_ARG
      fi
    done
  #end for
}

# Validate qualifiers for *emCCR test* command
validateTestQual()
{
  if [ "$_disconn" = "true" ]; then
    return 0
  fi
  for i in "$@"
    do
      if [ "$PLATFORM" = "Linux" ]; then
        j=`expr "${i}" : $hyphen`
      else
        j=`expr "${i}" : [$hyphen]`
      fi

      if [ ${j} -ne 0 ] ; then
        # We got a qualifier
        # Convert to lower case
        qual=`$ECHO $i | $TR '[A-Z]' '[a-z]' | $SED -e 's/ .*$//'`
        case "$qual" in
          "-verbose"                 ) ;;
          "-register"                ) ;;
          * ) banner
          $ECHO "\"${i}\" is an invalid qualifier for command \"${action}\""
            printUsage
            EXIT $ERR_INVALID_ARG 
            ;;
        esac
      fi
    done
  #end for
}

# Validate qualifiers for *emCCR clear* command
validateClearQual()
{
  if [ "$_disconn" = "true" ]; then
    return 0
  fi
  for i in "$@"
    do
      if [ "$PLATFORM" = "Linux" ]; then
        j=`expr "${i}" : $hyphen`
      else
        j=`expr "${i}" : [$hyphen]`
      fi

      if [ ${j} -ne 0 ] ; then
        # We got a qualifier
        # Convert to lower case
        qual=`$ECHO $i | $TR '[A-Z]' '[a-z]' | $SED -e 's/ .*$//'`
        case "$qual" in
          "-diagnostic"                 ) ;;
          -diagnostic=*                 ) ;;
          "-force"                      ) ;;
          "-completed"                  ) ;;
          * ) banner
          $ECHO "\"${i}\" is an invalid qualifier for command \"${action}\""
            printUsage
            EXIT $ERR_INVALID_ARG 
            ;;
        esac
      fi
    done
  #end for
}

# Validate qualifiers for *emCCR status* command
validateStatusQual()
{
  for i in "$@"
    do
      if [ "$PLATFORM" = "Linux" ]; then
        j=`expr "${i}" : $hyphen`
      else
        j=`expr "${i}" : [$hyphen]`
      fi

      if [ ${j} -ne 0 ] ; then
        # We got a qualifier
        if [ "$_disconn" = "true" ]; then
           banner
          $ECHO "\"${i}\" is an invalid qualifier for command \"${action}\""
          printUsage
          EXIT $ERR_INVALID_ARG
        else
          # Convert to lower case
          qual=`$ECHO $i | $TR '[A-Z]' '[a-z]' | $SED -e 's/ .*$//'`
          case "$qual" in
            "-diagnostic"                 ) ;;
            -diagnostic=*                 ) ;;
            * ) banner
              $ECHO "\"${i}\" is an invalid qualifier for command \"${action}\""
              printUsage
              EXIT $ERR_INVALID_ARG 
              ;;
          esac
        fi
      fi
    done
  #end for
}

# Validate qualifiers for *emCCR update_components* command
validateUpdateCompQual()
{
  for i in "$@"
    do
      if [ "$PLATFORM" = "Linux" ]; then
        j=`expr "${i}" : $hyphen`
      else
        j=`expr "${i}" : [$hyphen]`
      fi

      if [ ${j} -ne 0 ] ; then
        # We got a qualifier
        # Convert to lower case
        qual=`$ECHO $i | $TR '[A-Z]' '[a-z]' | $SED -e 's/ .*$//'`
        case "$qual" in
          "-silent"     ) 
                        silent_flag=1
                        ;;
          -staged_dir=* )
                        if [ -z "${DISTRIBUTION_QUALIFIER}" ]; then
                          STAGED_DIR_QUALIFIER=1
                        else
                          banner
                          # raise error
                          $ECHO "\"-staged_dir\" and \"-distribution\" qualifiers cannot be used together. Please provide either one."
                          printUsage
                          EXIT $INVALID_QUALIFIER_COMBINATION
                        fi
                        ;;
          "-staged_dir" )
                          banner
                          # missing qualifier
                          $ECHO "Missing qualifier value for -staged_dir"
                          printUsage
                          EXIT $MISSING_QUALIFIER_VALUE
                          ;;
          -distribution=* ) 
                        if [ -z "${STAGED_DIR_QUALIFIER}" ]; then
                          DISTRIBUTION_QUALIFIER=1 
                        else
                          banner
                          # raise error
                          $ECHO "\"-staged_dir\" and \"-distribution\" qualifiers cannot be used together. Please provide either one."
                          printUsage
                          EXIT $INVALID_QUALIFIER_COMBINATION
                        fi
                        ;;
          "-distribution" )
                          banner
                          # missing qualifier
                          $ECHO "Missing qualifier value for -distribution"
                          printUsage
                          EXIT $MISSING_QUALIFIER_VALUE
                          ;;
          * ) banner
              $ECHO "\"${i}\" is an invalid qualifier for command \"${action}\""
              printUsage
              EXIT $ERR_INVALID_ARG
              ;;
        esac
      fi
    done
  #end for
}

#Check whether user has given a diagnostic command.
#returns non-zero value if its a diagnostic cmd.
isDiagnosticCmd()
{
  argInfo=`$ECHO "$@" | $TR '[A-Z]' '[a-z]'`
  if [ "$PLATFORM" = "Linux" -o "$PLATFORM" = "SunOS" -o "$PLATFORM" = "HP-UX" -o "$PLATFORM" = "AIX" -o "$PLATFORM" = "OSF1" ]; then
    diagAction=`expr "$argInfo" : ".* -diagnostic"`
  else
    diagAction=`expr "$argInfo" : [".* -diagnostic"]`
  fi
  
  return $diagAction
}

# Handler for emCCR update_components command
updateComponents()
{
  # check if atleast one qualifier is given
  if [ -z "${DISTRIBUTION_QUALIFIER}" -a -z "${STAGED_DIR_QUALIFIER}" ]; then
    $ECHO "Please provide either of \"-staged_dir\" or \"-distribution\" qualifiers."
    printUsage
    return $ERR_INVALID_USAGE
  fi

  # Extract qualifier value
  if [ ! -z "${DISTRIBUTION_QUALIFIER}" ]; then
    qualExp="-[dD][iI][sS][tT][rR][iI][bB][uU][tT][iI][oO][nN]="
  else
    qualExp="-[sS][tT][aA][gG][eE][dD]_[dD][iI][rR]="
  fi

  for i in "$@"
    do
      if [ "$PLATFORM" = "Linux" -o "$PLATFORM" = "SunOS" -o "$PLATFORM" = "HP-UX" -o "$PLATFORM" = "AIX" -o "$PLATFORM" = "OSF1" ]; then
        _qualVal=`expr "$i" : "$qualExp\(.*\)"`
      else
        _qualVal=`expr "$i" : ["$qualExp\(.*\)"]`
      fi
      if [ ! -z "${_qualVal}" ]; then
         break
      fi
  done

  if [ ! -z "${DISTRIBUTION_QUALIFIER}" ]; then
    updateFromDistribution ${_qualVal}
    return $?
  else
    updateFromStagedDir ${_qualVal}
    return $?
  fi
}

# Handle -distribution qualifier of *update_components* command
updateFromDistribution()
{
  if [ -z "${1}" ]; then
    $ECHO "Missing qualifier value for -distribution" 
    printUsage
    return $MISSING_QUALIFIER_VALUE
  fi

  _distFile=$1
  _distFile=`$ECHO ${_distFile} | $AWK -f $CCR_HOME/bin/strip_path.awk PWD=$PWD`

  if [ ! -f ${_distFile} ]; then
    ERROR "Cannot access ${_distFile}"
    return $PKG_ACCESS_FAILURE
  fi

  if [ ! -r ${_distFile} ]; then
    ERROR "Cannot read ${_distFile}"
    return $PKG_ACCESS_FAILURE
  fi

  # Check if package exists in $CCR_HOME/inventory
  checkPkgDir ${_distFile}
  if [ $? -eq 0 ]
  then
    ERROR "Invalid package directory. Cannot install package from $CCR_HOME/inventory."
    return $INVALID_DIRECTORY
  fi

  # Expand the zip file in a temporary folder
  _distName=`$BASENAME ${_distFile}`
  _curDate=`$DATE +%m-%d-%Y_%H.%M.%S`
  _tmpDir=${CCR_TEMP}/${_distName}-${_curDate}-$$
    
  # Determine if the temporary directory exists and if so, attempt to 
  # delete it. 
  if [ -d ${_tmpDir} ]
  then
    $RMRF ${_tmpDir}
    if [ $? -ne 0 ]
    then
      ERROR "Previous installation detected and not able to remove."
      return $PKG_DEPLOY_FAILURE
    fi
  fi

  # Unpack the kit into the temporary directory, creating the 
  # directory as we go.
  $MKDIRP ${_tmpDir}
  _file=`$ECHO ${_distFile} | $AWK -f ${_OCMBinDir}/strip_path.awk PWD=$PWD`
  $CD ${_tmpDir} > /dev/null 2>&1
  $JAR -xf ${_file} ccr/inventory/pending > /dev/null 2>&1
  $CD $CWD > /dev/null 2>&1 
  if [ ! -d "${_tmpDir}/ccr/inventory/pending" ]; then
    ERROR "${_distFile} is not a valid OCM distribution."

    # Remove the temporary files.
    $RMRF ${_tmpDir} > /dev/null 2>&1
    return $INVALID_OCM_PKG
  fi
  
  # Invoke update from staged directory
  updateFromStagedDir ${_tmpDir}/ccr/inventory/pending
  retCode=$?

  # Remove the temporary files.
  $RMRF ${_tmpDir}

  return $retCode
}

# Handle -staged_dir qualifier of *update_components* command
updateFromStagedDir()
{
  if [ -z "${1}" ]; then
    $ECHO "Missing qualifier value for -staged_dir" 
    printUsage
    return $MISSING_QUALIFIER_VALUE
  fi

  _stagedDir=$1
  _stagedDir=`$ECHO ${_stagedDir} | $AWK -f $CCR_HOME/bin/strip_path.awk PWD=$PWD`

  if $TEST ! -e ${_stagedDir} ; then
    ERROR "Cannot access directory ${_stagedDir}"
    return $PKG_ACCESS_FAILURE
  fi

  if [ ! -d ${_stagedDir} ]; then
    ERROR "${_stagedDir} is not a directory"
    return $NOT_A_DIRECTORY
  fi

  if [ ! -r ${_stagedDir} ]; then
    ERROR "Cannot read from directory ${_stagedDir}"
    return $PKG_ACCESS_FAILURE
  fi

  # Check if package exists in $CCR_HOME/inventory
  checkPkgDir ${_stagedDir}
  if [ $? -eq 0 ]
  then
    ERROR "Invalid package directory. Cannot install package from $CCR_HOME/inventory."
    return $INVALID_DIRECTORY
  fi

  # Check if there are any packages to deploy/install.
  $LS ${_stagedDir}/*.jar > /dev/null 2>&1

  # If there is no package then return
  if [ $? -ne 0 ]; then
    ECHO_FUNC "No Oracle Configuration Manager packages are candidates for updating."
    return $SUCCESS
  fi

  # obtain synchronization lock
  if [ -f ${_collectorLock} ]
  then
   ECHO_FUNC "Another operation is in progress. Please wait..."
  fi 
  $LOCKFILE -5 -r 60 -l 600 ${_collectorLock} > /dev/null 2>&1


  if [ $? -eq 0 ]; then

    # Change ownership to CCR_HOME owner
    changeOwner "${_collectorLock}"

    # lock obtained
    collLocktaken=1
    retCode=$SUCCESS
    for _package in ${_stagedDir}/*.jar
    do
      if [ $silent_flag -eq 0 ]; then
        ${_OCMBinDir}/deployPackages -u ${_package} 
      else
        ${_OCMBinDir}/deployPackages -u ${_package} > /dev/null 2>&1
      fi
      retVal=$?
      if [ $retVal -ne $SUCCESS -a $retCode -eq $SUCCESS ]; then
        retCode=$retVal
      fi
    done

    # Read scheduler state from state file, make sure it hasn't been 
    # forcefully stopped vs. "DOWN_FOR_UPGRADE"
    #
    checkSchedulerState
    _proceedWithStart=1
    if [ "${_schedState}" = "STOPPED" ] ; then
      _proceedWithStart=0
    fi

    # we're starting the scheduler after upgrade
    if [ ${_proceedWithStart} -ne 0 ] ; then
      $sched_ctl -upgrade start > /dev/null 2>&1
    fi

    # release lock
    _tmpCollLock=`$LS -l ${_collectorLock} | $AWK '{print $NF}'`
    $RMF ${_collectorLock}
    $RMF ${_tmpCollLock}
    collLocktaken=0
    return $retCode
  else
    ERROR "Unable to synchronize operation. Verify no other operation is in progress;"
    ERROR "remove the file ${_collectorLock} if present and retry the operation."

    return $ERR_LOCK_FAILURE
  fi
}

# Check if package exists in $CCR_HOME/inventory. Return 0 if yes 
# otherwise non-zero.
# Params
# $1 - staged directory or distribution location
checkPkgDir()
{
  if [ ! -d "$1" ]; then
    # go to the package directory
    $CD `$DIRNAME $1`
    _pkgDir=`$DIRNAME $1`
  else
    $CD $1
    _pkgDir=$1
  fi
  
  # get back to previous working directory
  $CD $CWD

  # compare
  $ECHO $_pkgDir | $EGREP "^$CCR_HOME/inventory" > /dev/null 2>&1
  return $?
}

# If not silent then print to STDOUT
ECHO_FUNC()
{
 if [ $silent_flag -eq 0 ]; then
  $ECHO "$@"
 fi
}

# Expects a file/directory as input and resets its ownership to CCR_HOME owner
changeOwner()
{
 $CHOWN "$ccrOwner:$ccrGroup" "$@" > /dev/null 2>&1
 return $?
}

# Resets ownership permissions after disconnected collection. 
resetDCPerms()
{
 changeOwner ${CCR_CONFIG_HOME}/config/default/targets.xml
 changeOwner ${CCR_CONFIG_HOME}/config/targets.xml 
 changeOwner ${CCR_CONFIG_HOME}/state/review/*
 changeOwner ${CCR_CONFIG_HOME}/state/upload/ocmconfig.jar
 changeOwner "${COLLECTOR_LOG}"
}

# Resets ownership of various critical OCM files to OH owner. 
# This should be invoked during initialization.
resetCCRPerms()
{
  changeOwner "${_collectorLock}"
  changeOwner "${_semaphoreLock}"
  changeOwner "${_semaphoreOp}"
  changeOwner "${_semaphoreUpdate}"
  changeOwner "${DEPLOY_LOG}"
  resetDCPerms 
}


# Retrieves the collector log file name and creates a file if it doesnot
# exists
setCollectorLog()
{
  if [ -f ${CCR_CONFIG_HOME}/config/collector.properties ] ; then
    COLLECTOR_LOG_NAME=`grep "^[ ]*log4j.appender.Rolling.File[ ]*" ${CCR_CONFIG_HOME}/config/collector.properties | cut -d= -f 2 | cut -d/ -f 2`
  fi
  # Obtain collector log name from alternate collector.properties files, if necessary
  if [ -z "${COLLECTOR_LOG_NAME}" ] ; then
    if [ -f ${CCR_CONFIG_HOME}/config/default/collector.properties ] ; then
      COLLECTOR_LOG_NAME=`grep "^[ ]*log4j.appender.Rolling.File[ ]*" $CCR_CONFIG_HOME/config/default/collector.properties | cut -d= -f 2 | cut -d/ -f 2`
    fi
  fi
  if [ -z "${COLLECTOR_LOG_NAME}" ] ; then
    if [ -f ${CCR_HOME}/config/collector.properties ] ; then
      COLLECTOR_LOG_NAME=`grep "^[ ]*log4j.appender.Rolling.File[ ]*" $CCR_HOME/config/collector.properties | cut -d= -f 2 | cut -d/ -f 2`
    fi
  fi
  if [ -z "${COLLECTOR_LOG_NAME}" ] ; then
    if [ -f ${CCR_HOME}/config/default/collector.properties ] ; then
      COLLECTOR_LOG_NAME=`grep "^[ ]*log4j.appender.Rolling.File[ ]*" $CCR_HOME/config/default/collector.properties | cut -d= -f 2 | cut -d/ -f 2`
    fi
  fi

  if [ ! -z "${COLLECTOR_LOG_NAME}" ] ; then
    COLLECTOR_LOG=${CCR_CONFIG_HOME}/log/$COLLECTOR_LOG_NAME
    if [ ! -f ${COLLECTOR_LOG} ] ; then
      $TOUCH $COLLECTOR_LOG
      # Permission of collector.log is changed in resetDCPerms()
    fi
  fi
}

setCliJavaOpts()
{
  ## additional environment for Cli launch
  #
  # WLS-related environmental
  #
  _wlHome=""
  if [ ! -z "${WL_HOME}" ]
  then
     _wlHome=" -DWL_HOME=${WL_HOME}"
  fi
  _beaHome=""
  if [ ! -z "${BEA_HOME}" ]
  then
     _beaHome=" -DBEA_HOME=${BEA_HOME}"
  fi

  #
  # IDM instance related environmental variables.
  # 
  _oracleInstance=""
  if [ ! -z "${ORACLE_INSTANCE}" ]
  then
     _oracleInstance=" -DORACLE_INSTANCE=${ORACLE_INSTANCE}"
  fi

  # 
  # Pass along the user specified ORACLE_HOME if it was found.
  _userOracleHome=""
  if [ ! -z "${ORACLE_HOME}" ]
  then
      _userOracleHome=" -DUSER_ORACLE_HOME=${ORACLE_HOME}"
  fi
  #
  # Pass the EMAGENT Perl Trace env variable if present
  _emagent_perl_trace=""
  if [ ! -z "${EMAGENT_PERL_TRACE_LEVEL}" ]
  then
      _emagent_perl_trace=" -DEMAGENT_PERL_TRACE_LEVEL=${EMAGENT_PERL_TRACE_LEVEL}"
  fi
  #
  # Pass the CRS_HOME variable if present
  _crs_home=""
  if [ ! -z "${CRS_HOME}" ]
  then
      _crs_home=" -DCRS_HOME=${CRS_HOME}"
  fi
  #
  # Pass the CLUSTER_NAME variable if present
  _cluster_name=""
  if [ ! -z "${CLUSTER_NAME}" ]
  then
      _cluster_name=" -DCLUSTER_NAME=${CLUSTER_NAME}"
  fi
  #
  # EBS-related environmental
  _iasCfgHome=""
  if [ ! -z "${IAS_CONFIG_HOME}" ]
  then
     _iasCfgHome=" -DIAS_CONFIG_HOME=${IAS_CONFIG_HOME}"
  fi
  #
  # Pass LD_PRELOAD if specified
  _ld_preload=""
  if [ ! -z "${LD_PRELOAD}" ]
  then
      _ld_preload=" -DLD_PRELOAD=${LD_PRELOAD}"
  fi
  # 
  # Pass the ORACLE Inventory location if it was specified for override
  _oraInst_loc=""
  if [ ! -z "${ORAINST_LOC}" ]
  then
      _oraInst_loc=" -DORAINST_LOC=${ORAINST_LOC}"
  fi
  #
  # Pass an alternate HOSTNAME for this host if it is required
  _hostname=""
  if [ ! -z "${_HOSTNAME}" ]
  then
      _hostname=" -Doracle.sysman.ccr.hostname=${_HOSTNAME}"
  fi
  #
  # Pass the TNS_ADMIN variable if set 
  _tnsAdmin=""
  if [ ! -z "${TNS_ADMIN}" ]
  then
     _tnsAdmin=" -DTNS_ADMIN=${TNS_ADMIN}"
  fi
  #
  # Pass ORACLE_CONFIG_HOME if set
  _oracleCfgHome=""
  if [ ! -z "${ORACLE_CONFIG_HOME}" ]
  then
     _oracleCfgHome=" -DORACLE_CONFIG_HOME=${ORACLE_CONFIG_HOME}"
  fi
  _cliJavaOpts="${_wlHome}${_beaHome}${_oracleInstance}${_userOracleHome}${_emagent_perl_trace}${_crs_home}${_cluster_name}${_iasCfgHome}${_ld_preload}${_oraInst_loc}${_hostname}${_tnsAdmin}${_oracleCfgHome}"

  ## end additions for Cli launch
}

#
# Processing begins from here
#
exitIfNotOwner
setCollectorLog
resetCCRPerms
initSemaphores
determineJavaVersion
determineHttpClientClasspath

 # For test purposes... you can define this
_ccrtest_do_not_designate_as_central_anonymous_collector=""
if [ ! -z "${ccrtest_do_not_designate_as_central_anonymous_collector}" ]
then
   _ccrtest_do_not_designate_as_central_anonymous_collector="-Dccrtest_do_not_designate_as_central_anonymous_collector=true"
fi

trap 'cleanupTrap' INT

#define variables
#
#retCode is initialized to return an error code of 1 on exit.
#
#If retCode is not set by a call to an earlier command that gets processed
#use the retCode variable to exit the script. 
#It will consistently return an error code of 1.
#
retCode=1
hyphen="-"
action=""

# get the action
for i in "$@"
  do
    if [ "$PLATFORM" = "Linux" ]; then
      j=`expr "${i}" : $hyphen`
    else
      j=`expr "${i}" : [$hyphen]`
    fi

    if [ ${j} -eq 0 ] ; then
      if [ "$action" = "" ]; then
        validateCmd $i 
        # Convert command to lower case
        action=`$ECHO $i | $TR '[A-Z]' '[a-z]' | $SED -e 's/ .*$//'`
      else
        case "$action" in
          "set"                ) ;;
          "automatic_update"   ) ;;
          "_set"               ) ;;
          "_get"               ) ;;
          "_hold"              ) ;;
          "_resume"            ) ;;
          "disable_target"     ) ;;
          * )  # we only support one command
            banner
            $ECHO "Please provide only one command at a time."
            EXIT $ERR_INVALID_USAGE 
            ;;
        esac
      fi
    fi
  done
# for ends

if [ "$action" = "" ] ; then
  banner
  $ECHO "Please specify a command."
  printUsage
  EXIT $ERR_INVALID_USAGE 
fi 


# Got the action, now verify qualifiers for this action
case "$action" in
  "start"               ) validateStartQual "$@" $action ;;
  "status"              ) validateStatusQual "$@" $action ;;
  "collect"             ) validateCollectQual "$@"  $action ;;
  "upload"              ) validateUploadQual "$@" $action ;;
  "getupdates"          ) validateCollectQual "$@" $action ;;
  "test"                ) validateTestQual "$@" $action ;;
  "clear"               ) validateClearQual "$@" $action ;;
  "stop_abort"          ) validateStopAbortQual "$@" $action ;;
  "update_components"   ) validateUpdateCompQual "$@" $action ;;
  "_get"                ) ;;
  "_set"                ) ;;
  "_hold"               ) ;;
  "_resume"             ) ;;
  *                     ) validateNoQual "$@" $action ;;
esac

# Moved this here - in case of a mini-kit, an update is allowable w/o scheduler
# as is a request for help...
if [ "$action" != "update_components" -a \
     "$action" != "help" ] ; then
    exitIfExecsMissing
fi

#Check if its a diagnostic cmd
isDiagnosticCmd "$@"
diagCmd=$?

# Block prohibited commands if we are running as root, unless root owns the oracle home
if [ $rootUser -ne 0 -a ${_ORACLE_HOME_OWNER} -ne 0 ] ; then
 if [ "$action" != "status" -a \
      "$action" != "collect" -a \
      "$action" != "upload" -a \
      "$action" != "clear" -a \
      "$action" != "help" -a \
      "$_disconn" != "true" ] ; then
   banner
   $ECHO "\"${action}\" is not a valid command for root user."
   $ECHO "Please specify anyone of \"status, collect, upload, clear, help\" commands."
   EXIT $ERR_INVALID_USAGE
 else
   if [ "$action" != "status" -a \
      "$action" != "collect" -a \
      "$action" != "help" -a \
      "$_disconn" = "true" ] ; then
     banner
     $ECHO "\"${action}\" is not a valid command for root user."
     $ECHO "Please specify anyone of \"status, collect, help\" commands."
     EXIT $ERR_INVALID_USAGE
   else
     if [ "$action" = "upload" -a $diagCmd -eq 0  -a "$_disconn" != "true" ] ; then
      banner
      $ECHO "The upload command is only supported with -diagnostic qualifier for root user."
      EXIT $ERR_INVALID_USAGE
     fi
   fi
 fi
fi

if [ $diagCmd -ne 0 -a "$_disconn" != "true" ] ; then
  if [ "$action" = "status" -o \
       "$action" = "upload" -o \
       "$action" = "clear" ] ; then
  action="diagnostic"
 fi
fi

# call banner if not silent mode or any
# of these commands: "config","_get","_set","_hold" and _resume"
if [ $silent_flag -eq 0 -a \
     "$action" != "config" -a \
     "$action" != "_get" -a \
     "$action" != "_set" -a \
     "$action" != "_hold" -a \
     "$action" != "_resume" ] ; then
  # display banner
  banner
fi

# If no argument is specified or its help, diplay usage and exit.
if [ $# -eq 0 -o "$action" = "help" ] ; then
  printUsage
  EXIT $SUCCESS 
fi

# Handle disconnected mode
if [ "$_disconn" = "true" ]; then

  if [ "$action" = "collect" ]; then
    if [ -f ${_collectorLock} ]
    then
      $ECHO "A collection is already in progress. Please wait..."
    fi 
    $LOCKFILE -5 -r 60 -l 600 ${_collectorLock} > /dev/null 2>&1


    if [ $? -eq 0 ]
    then

      # Change ownership to CCR_HOME owner
      changeOwner "${_collectorLock}"

      collLocktaken=1
      $collector_executable  discover "$@" > /dev/null
      retCode=$?

      # reset disconnected collection permissions
      resetDCPerms

      if [ $retCode -eq 0 ]
      then
        $ECHO "Collection done."
        $ECHO ""
      else
        $ECHO "Collection failed."
        $ECHO ""
      fi
      _tmpCollLock=`$LS -l ${_collectorLock} | $AWK '{print $NF}'`
      $RMF ${_collectorLock}
      $RMF ${_tmpCollLock}
      collLocktaken=0
    else
      ERROR "Unable to synchronize collection. Verify no other collection is running;"
      ERROR "Remove the file ${_collectorLock} if present and retry the collection."
      retCode=$ERR_LOCK_FAILURE
    fi

  elif [ "$action" = "status" ]; then
    $ECHO "Log Directory            ${CCR_CONFIG_HOME}/log"
    $ECHO "Collector Mode           Disconnected"
    diagcheckStatus
    $ECHO "To switch to connected mode, please run ${CCR_HOME}/bin/configCCR"
    sqlVersionStatus
    retCode=$SUCCESS

  elif [ "$action" = "enable_target" -o \
         "$action" = "disable_target" ]; then
    exitIfNoJava
    setCliJavaOpts
    incrSemaphore ${_semaphoreOp}
    ${_JAVA_HOME_BIN}/java \
      ${_ccrtest_do_not_designate_as_central_anonymous_collector} \
      -DORACLE_HOME=${ORACLE_HOME} -DCCR_HOME=${CCR_HOME} -DCCR_CONFIG_HOME=${CCR_CONFIG_HOME} \
      -DPLATFORM=${PLATFORM} ${_perl5lib} ${shlib_path} ${jit_flag} ${_ccrJavaHome} ${_cliJavaOpts} \
      -DLOG_HOME=${CCR_CONFIG_HOME}/log -DPERL_HOME=$CCR_HOME/engines/${PLATFORM}/perl \
      -classpath ${G_HTTP_CLIENT_CLASSPATH}:${_collectorJar} oracle.sysman.ccr.collector.cli.Cli "$@"
    retCode=$?
    decrSemaphore ${_semaphoreOp}

  elif [ "$action" = "enable_diagchecks" -o \
         "$action" = "disable_diagchecks" ]; then
    exitIfNoJava
    incrSemaphore ${_semaphoreOp}
    ${_JAVA_HOME_BIN}/java -DORACLE_HOME=${ORACLE_HOME} -DCCR_HOME=${CCR_HOME} -DCCR_CONFIG_HOME=${CCR_CONFIG_HOME} \
      -DPLATFORM=${PLATFORM} ${_ccrJavaHome} \
      -DLOG_HOME=${CCR_CONFIG_HOME}/log \
      -classpath ${G_HTTP_CLIENT_CLASSPATH}:${_collectorJar} ${jit_flag} oracle.sysman.ccr.collector.cli.Cli "$@"
    retCode=$?
    decrSemaphore ${_semaphoreOp}

  elif [ "$action" = "update_components" ]; then
    incrSemaphore ${_semaphoreUpdate}
    updateComponents "$@"
    retCode=$?
    decrSemaphore ${_semaphoreUpdate}
  
  elif [ "$action" = "stop_abort" ]; then
    # This should be allowed as a NO-OP so that "emCCR stop_abort", 
    # if called internally by C code, does not fail.
    retCode=0

  elif [ "$action" = "start" -o \
         "$action" = "stop" -o \
         "$action" = "set" -o \
         "$action" = "hold" -o \
         "$action" = "resume" -o \
         "$action" = "upload" -o \
         "$action" = "getupdates" -o \
         "$action" = "test" -o \
         "$action" = "register" -o \
         "$action" = "automatic_update" -o \
         "$action" = "clear" -o \
         "$action" = "config" ]; then
    $ECHO "Command \"${action}\" is not supported in disconnected mode."
    printUsage
    retCode=$ERR_INVALID_USAGE

  else
    $ECHO "Please specify a valid command."
    printUsage
    retCode=$ERR_INVALID_ARG
  fi

  EXIT $retCode
fi

checkSchedulerState
#
# if scheduler is down for upgrade, the only command we want to see
# is "emCCR -upgrade start", unless our upgrade window has expired
#
if [ "${_schedState}" = "DOWN_FOR_UPGRADE" ] ; then
  if [ "$action" != "start" -o  $upgrade_flag -ne 1 ] ; then
    # get current date, date scheduler went down for upgrade (in seconds)
    if [ "$PLATFORM" = "Linux" ]; then
        _curDate=`$DATE "+%s"`
        _downDate=`$DATE --date="${_downTimestamp}" "+%s"`
    else
        Convert_date_Seconds `$DATE  '+%Y %m %d %H %M %S' `
        _curDate=$Seconds
        Convert_date_Seconds `$ECHO ${_downTimestamp} | $SED -e 's/[-:]/ /g' `
        _downDate=$Seconds
    fi
    # evaluate the difference
    _elapsed=`expr ${_curDate} - ${_downDate}`
    # if less than 600 (10 minutes) and positive, kick out
    if [ ${_elapsed} -le 600 -a ${_elapsed} -ge 0 ] ; then
      $ECHO "The scheduler is down for upgrade."
      EXIT $ERR_UPGRADE_IN_PROGRESS
    elif [  ${_elapsed} -lt 0 ] ; then
      $ECHO "The scheduler state indicates it is down for upgrade, but the timestamp is in the future; continuing with requested operation."
    else
      $ECHO "Upgrade did not complete within a 10 minute window; continuing."
    fi
  fi
fi

# process -silent start and -upgrade start commands
if [ $silent_flag -eq 1 -o $upgrade_flag -eq 1 ] ; then
  if [ "$action" = "start" ] ; then
    #
    # check for the scheduler state of STOPPED; if it has been stopped 
    # then it can only be started via the "emCCR start" command
    #
    if [ "${_schedState}" = "STOPPED" ] ; then
      EXIT $SUCCESS
    fi
  fi
fi

#
# get central collection info but only if scheduler exists. mini-kit has no scheduler, no DSF
if [ $cron_flag -ne 1 ] ; then
    if [ "$action" = "start" -o \
        "$action" = "status" ] ; then
        if [ -f $sched_executable ] ; then
            $collector_executable -silent show_central_collection
        fi
    fi
fi

#Command processing starts here
# collect, getupdates require locking
if [ "$action" = "collect" -o \
     "$action" = "upload" -o \
     "$action" = "getupdates" ] ; then
  if [ -f ${_collectorLock} ]
  then
    $ECHO "Another operation is in progress. Please wait..."
  fi 
  $LOCKFILE -5 -r 60 -l 600 ${_collectorLock} > /dev/null 2>&1
  if [ $? -eq 0 ]
  then
    # Change ownership to CCR_HOME owner
    changeOwner "${_collectorLock}"
    collLocktaken=1
    preCmdProcessing
    $sched_ctl "$@"
    retCode=$?
    postCmdProcessing "$retCode" 
    _tmpCollLock=`$LS -l ${_collectorLock} | $AWK '{print $NF}'`
    $RMF ${_collectorLock}
    $RMF ${_tmpCollLock}
    collLocktaken=0
  else
    ERROR "Unable to synchronize operation. Verify no other operation is in progress;"
    ERROR "remove the file ${_collectorLock} if present and retry the operation."
    retCode=$ERR_LOCK_FAILURE
  fi

elif [ "$action" = "start" -o \
       "$action" = "stop" -o \
       "$action" = "status" -o \
       "$action" = "hold" -o \
       "$action" = "resume" -o \
       "$action" = "stop_abort" ] ; then
  incrSemaphore ${_semaphoreOp}
  preCmdProcessing
  $sched_ctl "$@"
  retCode=$?

  if [ "$action" = "stop" -o \
         "$action" = "hold" ] ; then
      # Do a collection so that oracle_livelink target's status is uploaded
      $LOCKFILE -5 -r 60 -l 600 ${_collectorLock} > /dev/null 2>&1
      if [ $? -eq 0 ] ; then
        collLocktaken=1
        $collector_executable -silent discover collect upload "-collection=Oracle Configuration Manager,oracle_livelink" > /dev/null 2>&1
        _tmpCollLock=`$LS -l ${_collectorLock} | $AWK '{print $NF}'`
        $RMF ${_collectorLock}
        $RMF ${_tmpCollLock}
        collLocktaken=0
      fi
  fi

  if [ $retCode = 0 -a $silent_flag -eq 0 ] ; then
    if [ "$action" = "start" -o \
         "$action" = "status"  ] ; then
      postSchedulerStatus
      if [ "$action" = "start" ] ; then
        $ECHO ""
        $ECHO "Oracle Configuration Manager successfully started."
      fi
    fi
  fi
  postCmdProcessing "$retCode" 
  decrSemaphore ${_semaphoreOp}

elif [ "$action" = "set" ] ; then
  set_option=`$ECHO $2 | $TR '[A-Z]' '[a-z]' | $SED -e 's/ .*$//'`
  collection_interval=`$ECHO $set_option | $CUT -b 1-19`
  if [ $collection_interval = "collection_interval" ] ;
  then
    incrSemaphore ${_semaphoreOp}
    $sched_ctl "$@"
    retCode=$?
    decrSemaphore ${_semaphoreOp}
  elif [ "$2" = "" ]; then
    $ECHO "required SET command option was not specified."
    retCode=$ERR_INVALID_USAGE
    printUsage
  else
    $ECHO "\"${2}\" is not a valid SET command option."
    retCode=$ERR_INVALID_ARG
    printUsage
  fi

elif [ "$action" = "register" -o \
       "$action" = "test" ] ; then
  incrSemaphore ${_semaphoreOp}

  $collector_executable "-silent" "$@"
  retCode=$?

  decrSemaphore ${_semaphoreOp}
  if [  "$action" = "register" -a $retCode = 0 ] ; then
    $ECHO "REGISTER command completed successfully."
  fi

elif [ "$action" = "diagnostic" ] ; then
  incrSemaphore ${_semaphoreOp}
  $collector_executable "-silent" "$@"
  retCode=$?

  # Change ownership of all subdirectories under the state/diagnostic
  # directory.
  for _diagDirs in ${CCR_CONFIG_HOME}/state/diagnostic/*; do
      if [ -d $_diagDirs ]; then
          changeOwner $_diagDirs
      fi
  done

  decrSemaphore ${_semaphoreOp}

elif [ "$action" = "clear" ] ; then
  $ECHO "clear command must be used with -diagnostic qualifier"
  retCode=$ERR_INVALID_USAGE
  printUsage

elif [ "$action" = "automatic_update" ]; then
  exitIfNoJava
  incrSemaphore ${_semaphoreOp}
  ${_JAVA_HOME_BIN}/java -DORACLE_HOME=${ORACLE_HOME} -DCCR_HOME=${CCR_HOME} -DCCR_CONFIG_HOME=${CCR_CONFIG_HOME} \
    -DPLATFORM=${PLATFORM}  ${_perl5lib} ${shlib_path} ${jit_flag} ${_ccrJavaHome} \
    -DLOG_HOME=${CCR_CONFIG_HOME}/log -DPERL_HOME=$CCR_HOME/engines/${PLATFORM}/perl \
    -classpath ${G_HTTP_CLIENT_CLASSPATH}:${_collectorJar} oracle.sysman.ccr.collector.cli.Cli "$@"
  retCode=$?
  decrSemaphore ${_semaphoreOp}

elif  [ "$action" = "config" ] ; then
  ERROR "The command '${CCR_HOME}/bin/emCCR config' has been obsoleted."
  ERROR "Use '${CCR_HOME}/bin/configCCR' to reconfigure OCM."
  ERROR ""

  #${_JAVA_HOME_BIN}/java -DORACLE_HOME=${ORACLE_HOME}  -DCCR_CONFIG_HOME=${CCR_CONFIG_HOME} \
  #  -DPLATFORM=${PLATFORM}  ${_perl5lib} ${shlib_path} ${_ccrJavaHome} \
  #  -DLOG_HOME=${CCR_CONFIG_HOME}/log \
  #  -classpath ${_collectorJar} oracle.sysman.ccr.ui.EMCCRConfigAssistant "$@"
  #retCode=$?
  retCode=$ERR_INVALID_USAGE  

elif [ "$action" = "_get" -o \
       "$action" = "_set" -o \
       "$action" = "_hold" -o \
       "$action" = "_resume" ] ; then
  incrSemaphore ${_semaphoreOp}
  $sched_ctl "$@"
  retCode=$?
  decrSemaphore ${_semaphoreOp}

elif [ "$action" = "enable_target" -o \
       "$action" = "disable_target" ] ; then
  exitIfNoJava
  setCliJavaOpts
  incrSemaphore ${_semaphoreOp}
  ${_JAVA_HOME_BIN}/java \
    ${_ccrtest_do_not_designate_as_central_anonymous_collector} \
    -DORACLE_HOME=${ORACLE_HOME} -DCCR_HOME=${CCR_HOME} -DCCR_CONFIG_HOME=${CCR_CONFIG_HOME} \
    -DPLATFORM=${PLATFORM}  ${_perl5lib} ${shlib_path} ${_ccrJavaHome} ${_cliJavaOpts} \
    -DLOG_HOME=${CCR_CONFIG_HOME}/log -DPERL_HOME=$CCR_HOME/engines/${PLATFORM}/perl \
    -classpath ${G_HTTP_CLIENT_CLASSPATH}:${_collectorJar} ${jit_flag} oracle.sysman.ccr.collector.cli.Cli "$@"
  retCode=$?
  decrSemaphore ${_semaphoreOp}

elif [ "$action" = "enable_diagchecks" -o \
       "$action" = "disable_diagchecks" ]; then
  exitIfNoJava
  incrSemaphore ${_semaphoreOp}
  ${_JAVA_HOME_BIN}/java \
    ${_ccrtest_do_not_designate_as_central_anonymous_collector} \
    -DORACLE_HOME=${ORACLE_HOME} -DCCR_HOME=${CCR_HOME} -DCCR_CONFIG_HOME=${CCR_CONFIG_HOME} \
    -DPLATFORM=${PLATFORM} ${_ccrJavaHome} \
    -DLOG_HOME=${CCR_CONFIG_HOME}/log \
    -classpath ${G_HTTP_CLIENT_CLASSPATH}:${_collectorJar} ${jit_flag} oracle.sysman.ccr.collector.cli.Cli "$@"
  retCode=$?
  decrSemaphore ${_semaphoreOp}

elif [ "$action" = "update_components" ]; then
  incrSemaphore ${_semaphoreUpdate}
  updateComponents "$@"
  retCode=$?
  decrSemaphore ${_semaphoreUpdate}

else
  $ECHO "\"${action}\" is not a valid command."
  retCode=$ERR_INVALID_ARG
  printUsage
fi

trap 0

# If we have been invoked with -cron -silent start, exit $SUCCESS,
# if retCode is 24, i.e., if scheduler is already running
if [ "$action" = "start" -a \
     $cron_flag -eq 1    -a \
     $silent_flag -eq 1  -a \
     $retCode -eq 24 ]
then
  EXIT $SUCCESS
else
  EXIT $retCode
fi
